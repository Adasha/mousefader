const VALID_MODES=new Set(['mousemove','enterframe','redraw']),VALID_DIRECTIONS=new Set(['both','horizontal','vertical']),DEFAULT_MODE='redraw',DEFAULT_DIRECTION='both',DEFAULT_FPS=30,DEFAULT_RUNOFF=100,DEFAULT_ATTACK=1,DEFAULT_DECAY=1,VALID_EFFECTS={opacity:{min:0,max:1,rule:'opacity'},translateX:{rule:'transform',func:'translateX',unit:'px'},translateY:{rule:'transform',func:'translateY',unit:'px'},translateZ:{rule:'transform',func:'translateZ',unit:'px'},rotate:{rule:'transform',func:'rotate',unit:'deg'},rotateX:{rule:'transform',func:'rotateX',unit:'deg'},rotateY:{rule:'transform',func:'rotateY',unit:'deg'},rotateZ:{rule:'transform',func:'rotateZ',unit:'deg'},scale:{rule:'transform',func:'scale'},scaleX:{rule:'transform',func:'scaleX'},scaleY:{rule:'transform',func:'scaleY'},scaleY:{rule:'transform',func:'scaleY'},skewX:{rule:'transform',func:'skewX',unit:'deg'},skewY:{rule:'transform',func:'skewY',unit:'deg'},perspective:{rule:'transform',func:'perspective',unit:'px'},blur:{min:0,rule:'filter',func:'blur',unit:'px'},brightness:{min:0,rule:'filter',func:'brightness',unit:'%'},contrast:{min:0,rule:'filter',func:'contrast',unit:'%'},grayscale:{min:0,max:100,rule:'filter',func:'grayscale',unit:'%'},hueRotate:{rule:'filter',func:'hue-rotate',unit:'deg'},invert:{min:0,max:100,rule:'filter',func:'invert',unit:'%'},saturate:{min:0,max:100,rule:'filter',func:'saturate',unit:'%'},sepia:{min:0,max:100,rule:'filter',func:'sepia',unit:'%'}};let _target,_nodes,_params,_effects,_lastDeltas,_frameLoop,_pointer={};const constrain=(c,e,f)=>{return'number'==typeof c?(void 0!==e&&null!==e&&'number'==typeof e&&(c=Math.max(c,e)),void 0!==f&&null!==f&&'number'==typeof f&&(c=Math.min(c,f)),c):NaN},delta=(c,e,f)=>(f-e)*c+e,map=(c,e,f,g,j)=>(c-e)*(j-g)/(f-e)+g,XOR=(c,e)=>(c||e)&&!(c&&e);class MouseFader{constructor(c,e={}){this.target=c,_params=e,this.threshold=_params.hasOwnProperty('threshold')?_params.threshold:0,this.runoff=_params.hasOwnProperty('runoff')?_params.runoff:DEFAULT_RUNOFF,this.attack=_params.hasOwnProperty('attack')?_params.attack:1,this.decay=_params.hasOwnProperty('decay')?_params.decay:1,this.invert=_params.invert||!1,this.offsetX=_params.offsetX||0,this.offsetY=_params.offsetY||0,this.jitter=_params.jitter||0,this.direction=_params.direction||DEFAULT_DIRECTION,this.FPS=_params.FPS||DEFAULT_FPS,this.mode=_params.mode||DEFAULT_MODE,this.init()}get target(){return _target}set target(c){let e;if(c instanceof HTMLElement){if(console.log(`HTMLElement with ${c.children.length} children found`),1>c.children.length){let f=document.createElement('span');c.parentNode.insertBefore(f,c),f.appendChild(c),c=f}e=c.children}else if(c instanceof NodeList)console.log(`NodeList with ${c.length} childNodes found`),e=c;else return void console.log(`${c} is not a suitable target`);return 1>e.length?void console.log(`No children found on ${c}`):void(this.nodes=e,_lastDeltas=Array(this.nodes.length))}get threshold(){return _params.threshold}set threshold(c){_params.threshold=constrain(c,0)}get runoff(){return _params.runoff}set runoff(c){_params.runoff=constrain(c,0)}get boundary(){return this.threshold+this.runoff}get invert(){return _params.invert}set invert(c){_params.invert=!!c}get attack(){return _params.attack}set attack(c){_params.attack=constrain(c,0,1)}get decay(){return _params.decay}set decay(c){_params.decay=constrain(c,0,1)}get offsetX(){return _params.offsetX}get offsetY(){return _params.offsetY}set offsetX(c){_params.offsetX=c}set offsetY(c){_params.offsetY=c}get jitter(){return _params.jitter}set jitter(c){_params.jitter=constrain(c,0),this.setJitterValues()}get direction(){return _params.direction}set direction(c){VALID_DIRECTIONS.has(c)?_params.direction=c:console.log(`${c} not a valid direction.`)}get FPS(){return _params.FPS}set FPS(c){0<c&&'number'==typeof c?_params.FPS=constrain(c,0):console.log('Invalid FPS requested')}get mode(){return _params.mode}set mode(c){c===_params.mode?console.log(`Already in ${c} mode. Mode not changed.`):VALID_MODES.has(c)?_params.mode=c:console.log(`${c} not a recognised mode.`)}addEffect(c,e,f){if(VALID_EFFECTS.hasOwnProperty(c)){let g=VALID_EFFECTS[c];_effects=_effects||[],_effects.push({type:c,near:constrain(e,g.min,g.max),far:f===void 0?e:constrain(f,g.min,g.max),rule:g.rule,func:g.func,unit:g.unit})}else console.log(`${c} is not a supported effect type`)}hasEffect(){}effect(){}removeEffect(){}setJitterValues(){for(let c=0;c<this.nodes.length;c++)0<this.jitter?(this.nodes[c].dataset.jitterx=(Math.random()-0.5)*this.jitter,this.nodes[c].dataset.jittery=(Math.random()-0.5)*this.jitter):this.nodes[c].dataset.jitterx&&(delete this.nodes[c].dataset.jitterx,delete this.nodes[c].dataset.jittery)}init(){document.addEventListener('mousemove',this.updatePointer),this.update=this.update.bind(this),window.requestAnimationFrame(this.update)}updatePointer(c){_pointer.x=c.clientX,_pointer.y=c.clientY}update(){let e=document.documentElement;for(let f=0;f<this.nodes.length;f++){let g=this.nodes[f],j=_lastDeltas[f],k=g.getBoundingClientRect();if(0<=k.right&&k.left<=e.clientWidth&&0<=k.bottom&&k.top<=e.clientHeight||1>j){let p,q,s,l=0.5*(k.left+k.right)-this.offsetX-(g.dataset.jitterx||0),m=0.5*(k.top+k.bottom)-this.offsetY-(g.dataset.jittery||0),n=_pointer.x-l,o=_pointer.y-m;if(p='both'===this.direction?Math.sqrt(n*n+o*o):Math.abs('horizontal'===this.direction?n:o),q=constrain((p-this.threshold)/this.runoff,0,1),this.invert&&(q=1-q),s=j?j+(q-j)*(XOR(q>j,this.invert)?this.decay:this.attack):q,1>=s){let u={};for(let v=0;v<_effects.length;v++){let w=_effects[v],x=w.type,y=w.near,z=w.far,A=w.rule,B=w.func,C=w.unit||'',D=delta(s,y,z);B?(!u[A]&&(u[A]=[]),u[A].push(B+'('+D+C+')')):g.style[A]=`${D}${C}`}for(let v in u)g.style[v]=u[v].join(' ')}_lastDeltas[f]=s}}'redraw'===this.mode&&window.requestAnimationFrame(this.update)}}