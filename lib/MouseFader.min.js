'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _VALID_EFFECTS;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var VALID_MODES = new Set(['mousemove', 'enterframe', 'redraw']),
    VALID_DIRECTIONS = new Set(['both', 'horizontal', 'vertical']),
    DEFAULT_MODE = 'redraw',
    DEFAULT_DIRECTION = 'both',
    DEFAULT_FPS = 30,
    DEFAULT_RUNOFF = 100,
    DEFAULT_ATTACK = 1,
    DEFAULT_DECAY = 1,
    VALID_EFFECTS = (_VALID_EFFECTS = { opacity: { min: 0, max: 1, rule: 'opacity' }, translateX: { rule: 'transform', func: 'translateX', unit: 'px' }, translateY: { rule: 'transform', func: 'translateY', unit: 'px' }, translateZ: { rule: 'transform', func: 'translateZ', unit: 'px' }, rotate: { rule: 'transform', func: 'rotate', unit: 'deg' }, rotateX: { rule: 'transform', func: 'rotateX', unit: 'deg' }, rotateY: { rule: 'transform', func: 'rotateY', unit: 'deg' }, rotateZ: { rule: 'transform', func: 'rotateZ', unit: 'deg' }, scale: { rule: 'transform', func: 'scale' }, scaleX: { rule: 'transform', func: 'scaleX' }, scaleY: { rule: 'transform', func: 'scaleY' } }, _defineProperty(_VALID_EFFECTS, 'scaleY', { rule: 'transform', func: 'scaleY' }), _defineProperty(_VALID_EFFECTS, 'skewX', { rule: 'transform', func: 'skewX', unit: 'deg' }), _defineProperty(_VALID_EFFECTS, 'skewY', { rule: 'transform', func: 'skewY', unit: 'deg' }), _defineProperty(_VALID_EFFECTS, 'perspective', { rule: 'transform', func: 'perspective', unit: 'px' }), _defineProperty(_VALID_EFFECTS, 'blur', { min: 0, rule: 'filter', func: 'blur', unit: 'px' }), _defineProperty(_VALID_EFFECTS, 'brightness', { min: 0, rule: 'filter', func: 'brightness', unit: '%' }), _defineProperty(_VALID_EFFECTS, 'contrast', { min: 0, rule: 'filter', func: 'contrast', unit: '%' }), _defineProperty(_VALID_EFFECTS, 'grayscale', { min: 0, max: 100, rule: 'filter', func: 'grayscale', unit: '%' }), _defineProperty(_VALID_EFFECTS, 'hueRotate', { rule: 'filter', func: 'hue-rotate', unit: 'deg' }), _defineProperty(_VALID_EFFECTS, 'invert', { min: 0, max: 100, rule: 'filter', func: 'invert', unit: '%' }), _defineProperty(_VALID_EFFECTS, 'saturate', { min: 0, max: 100, rule: 'filter', func: 'saturate', unit: '%' }), _defineProperty(_VALID_EFFECTS, 'sepia', { min: 0, max: 100, rule: 'filter', func: 'sepia', unit: '%' }), _VALID_EFFECTS);var _target = void 0,
    _nodes = void 0,
    _centers = void 0,
    _params = void 0,
    _effects = void 0,
    _lastDeltas = void 0,
    _frameLoop = void 0,
    _pointer = {};var constrain = function constrain(c, e, f) {
  return 'number' == typeof c ? (void 0 !== e && null !== e && 'number' == typeof e && (c = Math.max(c, e)), void 0 !== f && null !== f && 'number' == typeof f && (c = Math.min(c, f)), c) : NaN;
},
    delta = function delta(c, e, f) {
  return (f - e) * c + e;
},
    map = function map(c, e, f, g, j) {
  return (c - e) * (j - g) / (f - e) + g;
},
    XOR = function XOR(c, e) {
  return (c || e) && !(c && e);
};
var MouseFader = function () {
  function MouseFader(c) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MouseFader);

    this.target = c, _params = e, this.threshold = _params.hasOwnProperty('threshold') ? _params.threshold : 0, this.runoff = _params.hasOwnProperty('runoff') ? _params.runoff : DEFAULT_RUNOFF, this.attack = _params.hasOwnProperty('attack') ? _params.attack : 1, this.decay = _params.hasOwnProperty('decay') ? _params.decay : 1, this.invert = _params.invert || !1, this.offsetX = _params.offsetX || 0, this.offsetY = _params.offsetY || 0, this.jitter = _params.jitter || 0, this.direction = _params.direction || DEFAULT_DIRECTION, this.FPS = _params.FPS || DEFAULT_FPS, this.mode = _params.mode || DEFAULT_MODE, this.init();
  }

  _createClass(MouseFader, [{
    key: 'addEffect',
    value: function addEffect(c, e, f) {
      var j = void 0;if (0 < (arguments.length <= 3 ? 0 : arguments.length - 3)) j = { rule: arguments.length <= 3 ? undefined : arguments[3], func: arguments.length <= 4 ? undefined : arguments[4], unit: arguments.length <= 5 ? undefined : arguments[5] };else if (VALID_EFFECTS.hasOwnProperty(c)) j = VALID_EFFECTS[c];else return void console.log(c + ' is not a supported effect type');_effects = _effects || [], _effects.push({ type: c, near: constrain(e, j.min, j.max), far: f !== void 0 && null !== f ? constrain(f, j.min, j.max) : e, rule: j.rule, func: j.func, unit: j.unit });
    }
  }, {
    key: 'hasEffect',
    value: function hasEffect() {}
  }, {
    key: 'effect',
    value: function effect() {}
  }, {
    key: 'removeEffect',
    value: function removeEffect() {}
  }, {
    key: 'init',
    value: function init() {
      document.addEventListener('mousemove', this.updatePointer), document.dispatchEvent(new MouseEvent('mousemove')), window.addEventListener('scroll', this.windowEvent.bind(this)), window.addEventListener('resize', this.windowEvent.bind(this)), this.update = this.update.bind(this), window.requestAnimationFrame(this.update);
    }
  }, {
    key: 'setCenters',
    value: function setCenters() {
      _centers = [];for (var c = 0; c < this.nodes.length; c++) {
        var e = this.nodes[c],
            f = e.getBoundingClientRect();_centers.push({ x: 0.5 * (f.left + f.right), y: 0.5 * (f.top + f.bottom) });
      }
    }
  }, {
    key: 'setJitterValues',
    value: function setJitterValues() {
      for (var c = 0; c < this.nodes.length; c++) {
        0 < this.jitter ? (this.nodes[c].dataset.jitterx = (Math.random() - 0.5) * this.jitter, this.nodes[c].dataset.jittery = (Math.random() - 0.5) * this.jitter) : this.nodes[c].dataset.jitterx && (delete this.nodes[c].dataset.jitterx, delete this.nodes[c].dataset.jittery);
      }
    }
  }, {
    key: 'updatePointer',
    value: function updatePointer(c) {
      _pointer.x = c.clientX, _pointer.y = c.clientY;
    }
  }, {
    key: 'windowEvent',
    value: function windowEvent() {
      this.setCenters();
    }
  }, {
    key: 'update',
    value: function update() {
      var e = document.documentElement;for (var f = 0; f < this.nodes.length; f++) {
        var g = this.nodes[f],
            j = _lastDeltas[f],
            k = g.getBoundingClientRect();if (0 <= k.right && k.left <= e.clientWidth && 0 <= k.bottom && k.top <= e.clientHeight || 1 > j) {
          var p = void 0,
              q = void 0,
              r = void 0,
              l = _centers[f].x - this.offsetX - (g.dataset.jitterx || 0),
              m = _centers[f].y - this.offsetY - (g.dataset.jittery || 0),
              n = _pointer.x - l,
              o = _pointer.y - m;if (p = 'both' === this.direction ? Math.sqrt(n * n + o * o) : Math.abs('horizontal' === this.direction ? n : o), q = constrain((p - this.threshold) / this.runoff, 0, 1), this.invert && (q = 1 - q), r = j ? j + (q - j) * (XOR(q > j, this.invert) ? this.decay : this.attack) : q, 1 >= r) {
            var s = {};for (var u = 0; u < _effects.length; u++) {
              var v = _effects[u],
                  w = v.type,
                  x = v.near,
                  y = v.far,
                  z = v.rule,
                  A = v.func,
                  B = v.unit || '',
                  C = delta(r, x, y);A ? (!s[z] && (s[z] = []), s[z].push(A + '(' + C + B + ')')) : g.style[z] = '' + C + B;
            }for (var _u in s) {
              g.style[_u] = s[_u].join(' ');
            }g.style.zIndex = 1e3 - Math.floor(1e3 * r);
          }_lastDeltas[f] = r;
        }
      }'redraw' === this.mode && window.requestAnimationFrame(this.update);
    }
  }, {
    key: 'target',
    get: function get() {
      return _target;
    },
    set: function set(c) {
      var e = void 0;if (c instanceof HTMLElement) {
        if (console.log('HTMLElement with ' + c.children.length + ' children found'), 1 > c.children.length) {
          var f = document.createElement('span');c.parentNode.insertBefore(f, c), f.appendChild(c), c = f;
        }e = c.children;
      } else if (c instanceof NodeList) console.log('NodeList with ' + c.length + ' childNodes found'), e = c;else return void console.log(c + ' is not a suitable target');return 1 > e.length ? void console.log('No children found on ' + c) : void (this.nodes = e, this.setCenters(), _lastDeltas = Array(this.nodes.length));
    }
  }, {
    key: 'threshold',
    get: function get() {
      return _params.threshold;
    },
    set: function set(c) {
      _params.threshold = constrain(c, 0);
    }
  }, {
    key: 'runoff',
    get: function get() {
      return _params.runoff;
    },
    set: function set(c) {
      _params.runoff = constrain(c, 0);
    }
  }, {
    key: 'boundary',
    get: function get() {
      return this.threshold + this.runoff;
    }
  }, {
    key: 'invert',
    get: function get() {
      return _params.invert;
    },
    set: function set(c) {
      _params.invert = !!c;
    }
  }, {
    key: 'attack',
    get: function get() {
      return _params.attack;
    },
    set: function set(c) {
      _params.attack = constrain(c, 0, 1);
    }
  }, {
    key: 'decay',
    get: function get() {
      return _params.decay;
    },
    set: function set(c) {
      _params.decay = constrain(c, 0, 1);
    }
  }, {
    key: 'offsetX',
    get: function get() {
      return _params.offsetX;
    },
    set: function set(c) {
      _params.offsetX = c;
    }
  }, {
    key: 'offsetY',
    get: function get() {
      return _params.offsetY;
    },
    set: function set(c) {
      _params.offsetY = c;
    }
  }, {
    key: 'jitter',
    get: function get() {
      return _params.jitter;
    },
    set: function set(c) {
      _params.jitter = constrain(c, 0), this.setJitterValues();
    }
  }, {
    key: 'direction',
    get: function get() {
      return _params.direction;
    },
    set: function set(c) {
      VALID_DIRECTIONS.has(c) ? _params.direction = c : console.log(c + ' not a valid direction.');
    }
  }, {
    key: 'FPS',
    get: function get() {
      return _params.FPS;
    },
    set: function set(c) {
      0 < c && 'number' == typeof c ? _params.FPS = constrain(c, 0) : console.log('Invalid FPS requested');
    }
  }, {
    key: 'mode',
    get: function get() {
      return _params.mode;
    },
    set: function set(c) {
      c === _params.mode ? console.log('Already in ' + c + ' mode. Mode not changed.') : VALID_MODES.has(c) ? _params.mode = c : console.log(c + ' not a recognised mode.');
    }
  }]);

  return MouseFader;
}();